

## 目前需要解决的问题：

- 如何diff出修改的地方？
	- 参考 virtual dom tree？
- 如何表示修改的地方并且告诉服务端？

## 这个项目中可以拿出做面试题的地方：

1. 如何找出两个数组中不同的元素（加入元素为数字）
2. 如何构建指定节点数目的完全二叉树
3. 设计一个实验概念机制

# 设计思路(Event sourcing + virtual dom algo + bigpipe/pjax)

## 前沿

自从在XX公司面试失败之后，每天工作时我都不禁的想一个问题，如何把技术发挥到极致，如何把项目做的极致。因为面试时他们常问我一类问题，大概是让我描述一件工作中记忆深刻的事情。我没有好的答案，现在才发现我做的工作都很平庸，没有什么亮点。

于是我决定做出点成绩！机会来了！

## 业务场景

我不能详细的全盘托出我现在做的东西，毕竟涉及商业机密。但是我可以抽象一点的说这个是。

想象我们需要对外提供类似于图片压缩或者视频转码的服务，启动这项服务需要填写很多的配置信息，比如端口号，主机名称，最大进程数，日志目录，还包括连接的数据库配置信息，比如数据库主机地址，数据库端口号，数据库账号密码。而且线上环境、测试环境、staging环境的配置各不相同。原来的操作是人工的去修改配置文件，这样是有风险的（比如修改错了，影响到了其他参数，或者忘记修改了某个参数，或者无法启动也不知道错误在哪）。于是我们决定把这项工作可视化，通过UI界面去完成操作，而不是直接修改配置文件。

所以你可以想象，UI界面一定是一个冗长的表单。传统的前端技术手段是，当用户修改完某些字段数据点击保存之后，提交整张表单到服务端，然后服务端再返回额外的信息。在这个业务场景中，返回的仍然是配置表单，但是会多一些附加信息，比如提示服务是否启动成功，高亮格式不正确的字段（例如IP地址格式问题）

## 问题

问题在于上面描述的最后一个步骤。我们假设表单有10个配置需要填写，而用户只修改了一个字段，则整个表达的数据都要上传。这样的效率会不会太低？进一步说，我们是否能只上传修改的字段？同理，如果服务端在返回数据时，只返回被修改了的信息，这样我们也能针对性的修改DOM以提高渲染效率。

综上，我们有以下问题需要解决：

- 如何找到被修改数据字段？因为我们的数据是以Object的形式存储，所以这涉及到Object diff的算法问题
- 即便找到了被修改的字段，我们怎么告诉服务端这个字段发生了修改？换句话说，我们以什么样的数据结构组织修改的数据并且回传
- 当我们接收到服务端返回的数据后，我们如何把它翻译成修改的数据，并且找到对应的DOM进行修改？

总而言之，我们的目标是，最少的信息交换，最少的页面修改，最高的执行效率。最后，我们会再次搭建一个传统的表单页面来对比效率究竟提升了多少

## event sourcing

我们记录数据的方式有两种，一种记录数据的最终值，大部分时候我们都这么做，比如当用户购买了一个商品之后把库存减一，数据库里永远保存的都是库存的最终值

还有一类记录数据的方式是记录每一次数据的操作情况，比如当用户购买了一个商品之后数据库里记录的是一个动作，类似于`{actionType: 'minus', count: 1}`，而当库存又增加时再记录一个动作`{actionType: 'plus', count: 10}`，如果你想知道最终值，则需要做一个累计的操作。

不同的记录方式对于数据的使用方意义也不同，有的数据最终结果很重要，比如门票，飞机票，如果采用event sourcing方式进行数据存储，那么每次想得到最终的时候必须要进行累计操作，非常耗费性能，何况也没有人关心过程；有的数据虽然过程很重要，或者虽然说不上过程重要，但至少结果不重要，比如你银行存折里的钱，没有人会每次花钱或者取钱的时候都看一眼存折里还剩多少。大部分会关心的是这个月花了多少，花在了哪些方面，对于这些欲求而言event sourcing就是很好的存储方式

## 关于Object的diff问题

如果想知道那些数据被改动了，最好的办法是在修改数据的时候给这个数据做上一个标记，标记它是“脏”的。如果你对React有所了解的话，每次你调用`SetState`方法时，实际上它就是做了这么一件事。其实我们的这个需求和React很像，不同的是React修改的是Virtual DOM，在判断是否需要re-render的时候找出哪些子树被修改就可以了。

但我们这里不能使用dirty check的办法。因为这个APP我们使用的是Vuejs框架，Vuejs使用的不是dirty check机制，虽然它有访问数据的set和get函数，但我们无权override。

数据的格式是一个对象，类似于：
```
config: {
	service: {
		host: '',
		port: '',
		account: '',
		password: ''
	},
	db: {
		host: '',
		port: '',
		account: '',
		password: ''
	}
}
```
我们把这个对象的数据映射到基于vuejs开发的界面上，因为vuejs是mvvm框架，所以所见即所得，当我们在视图上修改字段时，数据也相应做出了修改。那么当修改完毕提交之后，我们要做的是对比出这个object里那些值做出了修改。

我们可以把object想象成一棵树，对比修改实际上就是对比树的不同。

树的对比算法不算复杂，修改情况也可以枚举出来，无非是节点的增删改。

但为了让情况变得更简单一点，利于优化，我们在对比条件上做一些更针对业务场景的限制。例如，不可能出现节点增加和删除的情况。因为数据结构是确定的，从实际情况考虑就是，配置字段不可能随意的添加或者删除，所以也就不存在树的节点删除或添加的情况。

所以我们只需要对比叶子节点上的数据，而叶子节点上的数据肯定只有两类：基本数据类型和数组。基本数据类型有（经典面试题）：string, number, boolean, null, undefined。这一类数据非常好比较。问题在于比较数组类型。

对于比较数组类型，我们有两种选择
1. 以整个数组为单位，只要判断稍不同（无论新增还是删除还是修改），就整个数组重新下载
2. 以数组里的每一项为单位，找到被删除、新增和修改的项。但在实际情况中，每一项可以又是一个对象，所以还需要在这个基础上对比每一项里的对象是否有字段的修改。所有面临的又会是究竟是告诉服务端是数组的某一项发生了修改还是数组的某个字段发生了修改。但是这样又面临一个问题，我们怎么告诉究竟是数组里的哪一项发生了修改数组是不带id的，当然为了这个需求我们可以加上id，但这样有点不太好。

或者换一种想法，从业务出发，我们真的需要标记数组吗？关于数组的真正需求是什么？

